"""

Filter localization data.

This module provides functions for filtering LocData objects.
The functions take LocData as input and compute new LocData objects.

"""

import numpy as np
from surepy import LocData


def select_by_condition(locdata, condition):
    """
    Select by specifying conditions on data properties.

    Parameters
    ----------
    locdata : LocData
        Specifying the localization data from which to select localization data.
    condition : string
        Conditions as input in select method.
        More precise: query specifications to be used with pandas query.

    Returns
    -------
    LocData
        a new instance of LocData referring to the specified dataset.
    """

    # select
    new_indices = locdata.data.query(condition).index.values.tolist()

    # instantiate
    new_locdata = LocData.from_selection(locdata=locdata, indices=new_indices)

    # metadata
    del new_locdata.meta.history[:]
    new_locdata.meta.history.add(name='select_by_condition',
                         parameter='locdata={}, condition={}'.format(locdata, condition))

    return new_locdata


def select_by_region(locdata, roi, reduce=True):
    """
    Select localizations within specified rectangle, ellipse, polygon or 3D equivalents.

    Parameters
    ----------
    locdata : LocData
        Specifying the localization data from which to select localization data.
    roi : Roi Object or dict
        Region of interest as specified by Roi or dictionary with keys 'points' and 'type'. For Roi objects the
        reference attribute is ignored. Points are a list of tuples representing 1D, 2D or 3D coordinates.
        Type is a string identifier that can be either rectangle, ellipse, or polygon.
    reduce : Bool
        Return the reduced LocData object or keep references alive.

    Returns
    -------
    LocData
        New instance of LocData referring to the specified dataset.
    """
    # todo implement ellipse and polygon for 2D and 3D
    try:
        _roi = dict(points=roi.points, type=roi.type)
    except AttributeError:
        _roi = roi

    if _roi['type']=='rectangle':
        if len(_roi['points'])==2:
            new_locdata = select_by_condition(locdata, condition='{0} <= Position_x <= {1}'.format(*_roi['points']))
        elif len(_roi['points'])==4:
            new_locdata = select_by_condition(locdata, condition='{0} <= Position_x <= {1} and '
                                                          '{2} <= Position_y <= {3}'.format(*_roi['points']))
        elif len(_roi['points'])==6:
            new_locdata = select_by_condition(locdata, condition='{0} <= Position_x <= {1} and '
                                                          '{2} <= Position_y <= {3} and '
                                                          '{4} <= Position_z <= {5}'.format(*_roi['points']))
        else:
            raise TypeError('Point dimensions must be  1, 2 or 3.')

    else:
        raise NotImplementedError

    if reduce:
        new_locdata.reduce()

    return new_locdata


def select_by_image_mask(selection, mask, pixel_size):
    """
    Select by masking using a binary image(e.g. generated by thresholding a transmitted-light microscopy image.

    Parameters
    ----------
    selection : Selection
        specifying the localization data from which to select localization data.
    mask :
        binary image.
    pixel_size : tuple(float)
        pixel sizes for each dimension in units of localization coordinates.

    Returns
    -------
    Selection
        a new instance of Selection referring to the specified dataset.
    """
    raise NotImplementedError


def exclude_sparce_points(locdata, other_locdata, radius, min_samples):
    """
    Exclude localizations by thresholding a local density.

    A subset of localizations, that exhibit a small local density of localizations from locdata or alternatively from
    other_locdata, is identified as noise and excluded.
    Noise is identified by using a nearest-neighbor search (sklearn.neighbors.NearestNeighbors) to find all
    localizations within a circle (sphere) of the given `radius`. If the number of localizations is below the
    threshold value `min_samples`, the localization is considered to be noise.

    The method identifies the same noise points as done by the clustering algorithm DBSCAN [1]_.

    Parameters
    ----------
    locdata : LocData
        Specifying the localization data from which to exclude localization data.
    radius: float
        Radius of a circle or sphere in which neighbors are identified.
    min_samples : int
        The minimum number of samples in the neighborhood that need to be found for each localization to not be
        identified as noise.

    Returns
    -------
    Tuple of LocData
        Two Locdata objects are returned, one carrying all noise localizations, the other carrying all localizations
        except noise.

    References
    ----------
    .. [1] Martin Ester, Hans-Peter Kriegel, JÃ¶rg Sander, Xiaowei Xu,
       A density-based algorithm for discovering clusters in large spatial databases with noise.
       In: Evangelos Simoudis, Jiawei Han, Usama M. Fayyad (Hrsg.): Proceedings of the Second International Conference
       on Knowledge Discovery and Data Mining (KDD-96). AAAI Press, 1996, S. 226-231, ISBN 1-57735-004-9.
    """
    raise NotImplementedError


def random_subset(locdata, number_points):
    """
    Take a random subset of localizations.

    Parameters
    ----------
    locdata : LocData
        Specifying the localization data from which to select localization data.
    number_points : int
        Number of localizations to randomly choose from locdata.

    Returns
    -------
    LocData
        a new instance of LocData carrying the subset of localizations.
    """
    indices = np.random.choice(len(locdata), size=number_points)
    new_locdata = LocData.from_selection(locdata, indices)
    new_locdata.meta.history.add(name='random subset')

    return new_locdata